name: Deploy to AWS EC2

on:
  push:
    branches: [ main, feature/*, develop ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
          - development

jobs:
  setup-infrastructure:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    env:
      TF_VAR_aws_region: "eu-central-1"
      # SSH Public Key wird als Secret gespeichert und hier verwendet
      TF_VAR_github_public_key: "${{ secrets.SSH_PUBLIC_KEY }}"
      # IP für SSH-Zugriff (sollte für Produktionsumgebungen eingeschränkt werden)
      TF_VAR_your_ip: "0.0.0.0/0"

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: "1.5.0"

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: "eu-central-1"

    - name: Terraform Init
      run: |
        cd infra
        terraform init

    - name: Terraform Plan
      run: |
        cd infra
        terraform plan

    - name: Terraform Apply
      run: |
        cd infra
        terraform apply -auto-approve
        
        # Outputs in Environment-Variablen speichern
        echo "EC2_PUBLIC_IP=$(terraform output -raw public_ip)" >> $GITHUB_ENV
        echo "EC2_PUBLIC_DNS=$(terraform output -raw public_dns)" >> $GITHUB_ENV
        
    - name: Save outputs to file
      run: |
        mkdir -p ./outputs
        echo "${{ env.EC2_PUBLIC_IP }}" > ./outputs/ec2_public_ip.txt
        echo "${{ env.EC2_PUBLIC_DNS }}" > ./outputs/ec2_public_dns.txt
        
    - name: Upload outputs
      uses: actions/upload-artifact@v4
      with:
        name: terraform-outputs
        path: ./outputs/

  build-and-deploy:
    needs: setup-infrastructure
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      
    - name: Download Terraform outputs
      uses: actions/download-artifact@v4
      with:
        name: terraform-outputs
        path: ./outputs
        
    - name: Set environment variables
      run: |
        echo "EC2_PUBLIC_IP=$(cat ./outputs/ec2_public_ip.txt)" >> $GITHUB_ENV
        echo "EC2_PUBLIC_DNS=$(cat ./outputs/ec2_public_dns.txt)" >> $GITHUB_ENV

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2

    - name: Login to DockerHub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Build and push frontend Docker image
      uses: docker/build-push-action@v4
      with:
        context: ./frontend
        push: true
        tags: ${{ secrets.DOCKERHUB_USERNAME }}/reelmatch-frontend:latest

    - name: Build and push backend Docker image
      uses: docker/build-push-action@v4
      with:
        context: ./backend
        push: true
        tags: ${{ secrets.DOCKERHUB_USERNAME }}/reelmatch-backend:latest

    - name: Set up SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/ec2_key
        chmod 600 ~/.ssh/ec2_key
        
        # Warten, bis SSH verfügbar ist (max. 5 Minuten)
        echo "Warte auf SSH-Verfügbarkeit..."
        timeout 300 bash -c 'until nc -z ${{ env.EC2_PUBLIC_IP }} 22; do sleep 5; echo "Warte auf SSH..."; done'
        
        # SSH-Host zum known_hosts hinzufügen
        ssh-keyscan -H ${{ env.EC2_PUBLIC_IP }} >> ~/.ssh/known_hosts
        
        # SSH-Verbindung testen
        ssh -o StrictHostKeyChecking=no -i ~/.ssh/ec2_key ubuntu@${{ env.EC2_PUBLIC_IP }} "echo SSH-Verbindung erfolgreich!"

    - name: Prepare deployment files
      run: |
        # Erstelle Nginx-Konfigurationsdatei
        mkdir -p ./deploy/nginx
        cp ./nginx/nginx.conf ./deploy/nginx/
        
        # Kopiere docker-compose.prod.yml
        cp docker-compose.prod.yml ./deploy/

    - name: Deploy to EC2
      run: |
        # Erstelle notwendige Verzeichnisse auf EC2
        ssh -o StrictHostKeyChecking=no -i ~/.ssh/ec2_key ubuntu@${{ env.EC2_PUBLIC_IP }} "mkdir -p ~/reelmatch/nginx ~/reelmatch/certs"

        # Kopiere Deployment-Dateien
        scp -o StrictHostKeyChecking=no -i ~/.ssh/ec2_key -r ./deploy/* ubuntu@${{ env.EC2_PUBLIC_IP }}:~/reelmatch/
        scp -o StrictHostKeyChecking=no -i ~/.ssh/ec2_key ./scripts/deploy.sh ubuntu@${{ env.EC2_PUBLIC_IP }}:~/

        # Führe Deployment-Skript aus
        ssh -o StrictHostKeyChecking=no -i ~/.ssh/ec2_key ubuntu@${{ env.EC2_PUBLIC_IP }} "chmod +x ~/deploy.sh && ~/deploy.sh"

    - name: Show Deployment URL
      run: |
        echo "Deployment abgeschlossen!"
        echo "Anwendung ist verfügbar unter: http://${{ env.EC2_PUBLIC_IP }}"
        if [ -f ./outputs/ec2_public_dns.txt ] && [ -n "$(cat ./outputs/ec2_public_dns.txt)" ]; then
          echo "oder unter: http://$(cat ./outputs/ec2_public_dns.txt)"
        fi
