name: Deploy to AWS EC2

on:
  push:
    branches: [ main, feature/*, develop ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
          - development

jobs:
  setup-infrastructure:
    runs-on: ubuntu-latest
    env:
      TF_VAR_aws_access_key: ${{ secrets.AWS_ACCESS_KEY_ID }}
      TF_VAR_aws_secret_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      TF_VAR_dockerhub_username: ${{ secrets.DOCKERHUB_USERNAME }}
      TF_VAR_dockerhub_token: ${{ secrets.DOCKERHUB_TOKEN }}
      TF_VAR_aws_region: eu-central-1
      TF_VAR_github_public_key: "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC0WGP1EZykEtv5YGC9nMiPFW3U3DmZNzKFO5nEu6uozEHh4jLZzPNHSrfFTuQ2GnRDSt+XvOOFQhJ/F2weLn9Xy+QQnZMS+cLR8hKNOZ8/KnY9DxHbkPDgJKMrpdIoXitofKWfk2QGp/QK7A+gQf7YCwzYnR/n6XdEV3Kgt5/1pC6yiPvlJWDDCHLPQFxDuynA/EM7kx4jImvR9RRIGxSWBRlegVA1dD8oaqYTEXNAUQlIg7cAGWAQXXqPyEm1yfIbgaGGqgQoNzUxUxCnwkUqp5PYNbLfGY5mysVOx0w0cZS9SYQ4QoK71LWkvNTn6n+X/MAO5FgzGbQpLjazGqKZ" 

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v1
      with:
        terraform_version: 1.0.0

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: eu-central-1

    - name: Terraform Init
      run: |
        cd infra
        terraform init

    - name: Terraform Plan
      run: |
        cd infra
        terraform plan

    - name: Terraform Apply
      run: |
        cd infra
        terraform apply -auto-approve
        echo "EC2_PUBLIC_IP=$(terraform output -raw public_ip)" >> $GITHUB_ENV
        echo "EC2_PUBLIC_DNS=$(terraform output -raw public_dns)" >> $GITHUB_ENV
        
    - name: Save outputs to file
      run: |
        mkdir -p ./outputs
        echo "$(terraform -chdir=infra output -raw public_ip)" > ./outputs/ec2_public_ip.txt
        echo "$(terraform -chdir=infra output -raw public_dns)" > ./outputs/ec2_public_dns.txt
        
    - name: Upload outputs
      uses: actions/upload-artifact@v3
      with:
        name: terraform-outputs
        path: ./outputs/

  build-and-deploy:
    needs: setup-infrastructure
    runs-on: ubuntu-latest
    env:
      DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
      DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      
    - name: Download Terraform outputs
      uses: actions/download-artifact@v3
      with:
        name: terraform-outputs
        path: ./outputs
        
    - name: Set environment variables
      run: |
        echo "EC2_PUBLIC_IP=$(cat ./outputs/ec2_public_ip.txt)" >> $GITHUB_ENV
        echo "EC2_PUBLIC_DNS=$(cat ./outputs/ec2_public_dns.txt)" >> $GITHUB_ENV

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v1

    - name: Login to DockerHub
      uses: docker/login-action@v1
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Build and push frontend Docker image
      uses: docker/build-push-action@v2
      with:
        context: ./frontend
        push: true
        tags: ${{ secrets.DOCKERHUB_USERNAME }}/reelmatch-frontend:latest

    - name: Build and push backend Docker image
      uses: docker/build-push-action@v2
      with:
        context: ./backend
        push: true
        tags: ${{ secrets.DOCKERHUB_USERNAME }}/reelmatch-backend:latest

    - name: Set up SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/ec2_key
        chmod 600 ~/.ssh/ec2_key
        
        # Warten, bis SSH verf端gbar ist (max. 5 Minuten)
        echo "Warte auf SSH-Verf端gbarkeit..."
        timeout 300 bash -c 'until nc -z ${{ env.EC2_PUBLIC_IP }} 22; do sleep 5; echo "Warte auf SSH..."; done'
        
        # SSH-Host zum known_hosts hinzuf端gen
        ssh-keyscan -H ${{ env.EC2_PUBLIC_IP }} >> ~/.ssh/known_hosts
        
        # SSH-Verbindung testen
        ssh -o StrictHostKeyChecking=no -i ~/.ssh/ec2_key ec2-user@${{ env.EC2_PUBLIC_IP }} "echo SSH-Verbindung erfolgreich!"

    - name: Prepare deployment files
      run: |
        # Erstelle Nginx-Konfigurationsdatei
        mkdir -p ./deploy/nginx
        cp ./nginx/nginx.conf ./deploy/nginx/
        
        # Kopiere docker-compose.prod.yml
        cp docker-compose.prod.yml ./deploy/

    - name: Deploy to EC2
      run: |
        # Erstelle notwendige Verzeichnisse auf EC2
        ssh -o StrictHostKeyChecking=no -i ~/.ssh/ec2_key ec2-user@${{ env.EC2_PUBLIC_IP }} "mkdir -p ~/reelmatch/nginx ~/reelmatch/certs"

        # Kopiere Deployment-Dateien
        scp -o StrictHostKeyChecking=no -i ~/.ssh/ec2_key -r ./deploy/* ec2-user@${{ env.EC2_PUBLIC_IP }}:~/reelmatch/
        scp -o StrictHostKeyChecking=no -i ~/.ssh/ec2_key ./scripts/deploy.sh ec2-user@${{ env.EC2_PUBLIC_IP }}:~/

        # F端hre Deployment-Skript aus
        ssh -o StrictHostKeyChecking=no -i ~/.ssh/ec2_key ec2-user@${{ env.EC2_PUBLIC_IP }} "chmod +x ~/deploy.sh && ~/deploy.sh"

    - name: Show Deployment URL
      run: |
        echo "Deployment abgeschlossen!"
        echo "Frontend URL: http://${{ env.EC2_PUBLIC_IP }}"
        echo "Backend API URL: http://${{ env.EC2_PUBLIC_IP }}/api"
