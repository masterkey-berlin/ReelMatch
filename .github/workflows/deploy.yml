name: Deploy to AWS EC2

on:
  push:
    branches: 
      - main
      - 'feature/**'  # Trigger auch für alle Feature-Branches
  pull_request:
    branches: [ main ]
  workflow_dispatch:  # Manueller Trigger über die GitHub UI

env:
  AWS_REGION: eu-central-1
  DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
  DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
  TF_VAR_aws_access_key: ${{ secrets.AWS_ACCESS_KEY_ID }}
  TF_VAR_aws_secret_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  TF_VAR_dockerhub_username: ${{ secrets.DOCKERHUB_USERNAME }}
  TF_VAR_dockerhub_token: ${{ secrets.DOCKERHUB_TOKEN }}

jobs:
  setup-infrastructure:
    name: Setup Infrastructure
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_wrapper: false

    - name: Terraform Init
      working-directory: ./infra
      run: |
        terraform init

    - name: Terraform Plan
      id: plan
      working-directory: ./infra
      run: |
        terraform plan -no-color -input=false -out=tfplan
        terraform show -no-color tfplan > tfplan.txt
      continue-on-error: false

    - name: Terraform Plan Status
      if: steps.plan.outcome == 'failure'
      run: exit 1

    - name: Terraform Apply
      working-directory: ./infra
      run: |
        terraform apply -auto-approve -input=false tfplan

    - name: Get EC2 Public IP
      id: ec2_ip
      working-directory: ./infra
      run: |
        echo "EC2_PUBLIC_IP=$(terraform output -raw instance_public_ip)" >> $GITHUB_ENV
        echo "EC2_PUBLIC_DNS=$(terraform output -raw instance_public_dns)" >> $GITHUB_ENV

    - name: Save EC2 IP to GitHub Variables
      run: |
        echo "EC2_PUBLIC_IP=${{ env.EC2_PUBLIC_IP }}" >> $GITHUB_ENV
        echo "EC2_PUBLIC_DNS=${{ env.EC2_PUBLIC_DNS }}" >> $GITHUB_ENV

  build-and-deploy:
    name: Build and Deploy
    needs: setup-infrastructure
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Login to Docker Hub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2

    - name: Build and push frontend
      uses: docker/build-push-action@v4
      with:
        context: ./frontend
        push: true
        tags: ${{ secrets.DOCKERHUB_USERNAME }}/reelmatch-frontend:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Build and push backend
      uses: docker/build-push-action@v4
      with:
        context: ./backend
        push: true
        tags: ${{ secrets.DOCKERHUB_USERNAME }}/reelmatch-backend:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Generate SSH key
      run: |
        mkdir -p ~/.ssh
        ssh-keygen -t rsa -b 4096 -f ~/.ssh/ec2_key -N ""
        echo "SSH_PUBLIC_KEY=$(cat ~/.ssh/ec2_key.pub)" >> $GITHUB_ENV
        echo "SSH_PRIVATE_KEY=$(cat ~/.ssh/ec2_key | base64 -w0)" >> $GITHUB_ENV

    - name: Add SSH key to EC2
      uses: shimataro/ssh-key-action@v2
      with:
        key: ${{ env.SSH_PRIVATE_KEY }}
        name: github-actions-key
        known_hosts: 'just-a-placeholder-so-we-dont-get-errors'

    - name: Deploy to EC2
      env:
        EC2_IP: ${{ env.EC2_PUBLIC_IP }}
        SSH_PRIVATE_KEY: ${{ env.SSH_PRIVATE_KEY }}
      run: |
        mkdir -p ~/.ssh
        echo "$SSH_PRIVATE_KEY" | base64 -d > ~/.ssh/ec2_key
        chmod 600 ~/.ssh/ec2_key
        
        # Create deployment script
        cat > deploy.sh << 'EOL'
        #!/bin/bash
        set -e
        
        # Create necessary directories
        mkdir -p ~/app/nginx
        
        # Create .env file
        cat > ~/app/.env << EOF
        DOCKERHUB_USERNAME=$DOCKERHUB_USERNAME
        DOCKERHUB_TOKEN=$DOCKERHUB_TOKEN
        DB_USER=postgres
        DB_PASSWORD=$(openssl rand -base64 32)
        DB_NAME=reelmatch
        JWT_SECRET=$(openssl rand -base64 32)
        NODE_ENV=production
        REACT_APP_API_URL=/api
        EOF
        
        # Copy docker-compose file
        cat > ~/app/docker-compose.prod.yml << 'EOF'
        version: '3.8'
        services:
          frontend:
            image: ${DOCKERHUB_USERNAME}/reelmatch-frontend:latest
            restart: always
            environment:
              - NODE_ENV=production
              - REACT_APP_API_URL=/api
            depends_on:
              - backend
            networks:
              - reelmatch-network

          backend:
            image: ${DOCKERHUB_USERNAME}/reelmatch-backend:latest
            restart: always
            environment:
              - NODE_ENV=production
              - DB_HOST=db
              - DB_USER=${DB_USER}
              - DB_PASSWORD=${DB_PASSWORD}
              - DB_NAME=${DB_NAME}
              - JWT_SECRET=${JWT_SECRET}
            depends_on:
              - db
            networks:
              - reelmatch-network

          db:
            image: postgres:13-alpine
            environment:
              - POSTGRES_USER=${DB_USER}
              - POSTGRES_PASSWORD=${DB_PASSWORD}
              - POSTGRES_DB=${DB_NAME}
            volumes:
              - postgres_data:/var/lib/postgresql/data
            networks:
              - reelmatch-network
            restart: always

          nginx:
            image: nginx:alpine
            ports:
              - "80:80"
              - "443:443"
            volumes:
              - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
              - ./certs:/etc/letsencrypt
            depends_on:
              - frontend
              - backend
            restart: always
            networks:
              - reelmatch-network

        networks:
          reelmatch-network:
            driver: bridge

        volumes:
          postgres_data:
        EOF
        
        # Pull and run containers
        cd ~/app
        docker-compose -f docker-compose.prod.yml pull
        docker-compose -f docker-compose.prod.yml up -d
        EOL
        
        # Copy and execute deployment script
        scp -o StrictHostKeyChecking=no -i ~/.ssh/ec2_key deploy.sh ec2-user@$EC2_IP:~
        ssh -o StrictHostKeyChecking=no -i ~/.ssh/ec2_key ec2-user@$EC2_IP "chmod +x ~/deploy.sh && ~/deploy.sh"

    - name: Show Deployment URL
      run: |
        echo "Deployment successful!"
        echo "Application URL: http://${{ env.EC2_PUBLIC_IP }}"
        echo "EC2 Public DNS: ${{ env.EC2_PUBLIC_DNS }}"
